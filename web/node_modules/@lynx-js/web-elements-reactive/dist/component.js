import { boostedQueueMicrotask } from './boostedQueueMicrotask.js';
function convertStyleWithPriority(value, priority) {
    if (priority) {
        return value + ' !important';
    }
    else {
        return value;
    }
}
export function Component(tag, attributeReactiveClasses, template) {
    let templateElement;
    if (template) {
        templateElement = document.createElement('template');
        templateElement.innerHTML = template;
        document.body.appendChild(templateElement);
    }
    return (target, { addInitializer }) => {
        const observedStyleProperties = new Set([
            ...attributeReactiveClasses
                .filter((e) => e.observedCSSProperties)
                .map((e) => e.observedCSSProperties)
                .reduce((p, r) => p.concat(r), []),
        ]);
        // @ts-ignore
        class CustomElement extends target {
            static registerPlugin(reactiveClass) {
                CustomElement.observedAttributes.push(...reactiveClass.observedAttributes);
                if (reactiveClass.observedCSSProperties) {
                    for (const property of reactiveClass.observedCSSProperties) {
                        observedStyleProperties.add(property);
                    }
                }
                attributeReactiveClasses.push(reactiveClass);
            }
            static observedAttributes = [
                ...(target.observedAttributes ?? []),
                ...attributeReactiveClasses
                    .map((e) => e.observedAttributes)
                    .reduce((p, r) => p.concat(r), []),
                'class',
            ];
            #attributeReactives = [];
            constructor() {
                super();
                if (templateElement) {
                    this.attachShadow({ mode: 'open', delegatesFocus: true });
                    const template = templateElement.content.cloneNode(true);
                    this.shadowRoot?.append(template);
                }
                this.#attributeReactives = attributeReactiveClasses.map((oneClass) => {
                    const oneAttributeReactive = new oneClass(this);
                    return oneAttributeReactive;
                });
                this.#cleanFalseAttributes();
            }
            /** handle observing styles */
            #checking = false;
            #previousStyle = new Map();
            #responseStyleChange() {
                if (!this.#checking && observedStyleProperties.size) {
                    this.#checking = true;
                    boostedQueueMicrotask(this.#invokeStyleHandler, this);
                }
            }
            #invokeStyleHandler() {
                const computedStyle = getComputedStyle(this);
                for (const propertyName of observedStyleProperties) {
                    const value = computedStyle.getPropertyValue(propertyName);
                    const priority = computedStyle.getPropertyPriority(propertyName);
                    const propertyValue = convertStyleWithPriority(value.trim(), priority);
                    if (this.#previousStyle.get(propertyName) !== propertyValue) {
                        for (const oneReactive of this.#attributeReactives) {
                            oneReactive.cssPropertyChangedHandler?.[propertyName]?.call(oneReactive, propertyValue, propertyName);
                        }
                    }
                }
                this.#checking = false;
            }
            /** handle attribute='false' */
            setAttribute(qualifiedName, value) {
                if (value.toString() === 'false'
                    && !target.notToFilterFalseAttributes?.has(qualifiedName)
                    && !qualifiedName.startsWith('data-')) {
                    this.removeAttribute(qualifiedName);
                    return;
                }
                super.setAttribute(qualifiedName, value);
            }
            #cleanFalseAttributes() {
                const attributes = this.attributes;
                for (let index = 0, attr; (attr = attributes.item(index)); index++) {
                    if (attr.value === 'false'
                        && !target.notToFilterFalseAttributes?.has(attr.name)
                        && !attr.name.startsWith('data-')) {
                        this.removeAttributeNode(attr);
                    }
                }
            }
            #connected = false;
            /** handel custom element life-cycles */
            attributeChangedCallback(name, oldValue, newValue) {
                super.attributeChangedCallback
                    && super.attributeChangedCallback(name, oldValue, newValue);
                if (!target.notToFilterFalseAttributes?.has(name)
                    && !name.startsWith('data-')) {
                    if (oldValue === 'false')
                        oldValue = null;
                    if (newValue === 'false') {
                        newValue = null;
                        this.removeAttribute(name);
                    }
                }
                if (oldValue !== newValue) {
                    if (this.#connected && (name === 'class' || name === 'style')) {
                        this.#responseStyleChange();
                    }
                    for (const oneReactive of this.#attributeReactives) {
                        if (oneReactive.attributeChangedHandler?.[name]) {
                            const { handler, noDomMeasure } = oneReactive.attributeChangedHandler[name];
                            if (noDomMeasure) {
                                handler.call(oneReactive, newValue, oldValue, name);
                            }
                            else if (this.#connected) {
                                boostedQueueMicrotask(() => handler.call(oneReactive, newValue, oldValue, name));
                            }
                        }
                    }
                }
            }
            #invokeAfterConnectedAttributeChangedHandler() {
                this.getAttributeNames().forEach((attributeName) => {
                    for (const oneReactive of this.#attributeReactives) {
                        if (oneReactive.attributeChangedHandler?.[attributeName]) {
                            const { handler, noDomMeasure } = oneReactive.attributeChangedHandler[attributeName];
                            if (!noDomMeasure) {
                                boostedQueueMicrotask(() => handler.call(oneReactive, this.getAttribute(attributeName), null, attributeName));
                            }
                        }
                    }
                });
            }
            connectedCallback() {
                super.connectedCallback?.();
                this.#attributeReactives.forEach((oneAttributeReactive) => {
                    oneAttributeReactive.connectedCallback?.();
                });
                this.#responseStyleChange();
                boostedQueueMicrotask(this.#invokeAfterConnectedAttributeChangedHandler, this);
                this.#connected = true;
            }
            disconnectedCallback() {
                super.disconnectedCallback?.();
                this.#attributeReactives.forEach((oneAttributeReactive) => {
                    oneAttributeReactive.dispose?.();
                });
            }
        }
        addInitializer(() => {
            customElements.define(tag, CustomElement);
        });
        return CustomElement;
    };
}
//# sourceMappingURL=component.js.map