/**
// Copyright 2023 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
*/
import type { AttributeChangeHandler } from './registerAttributeHandler.js';
import type { StyleChangeHandler } from './registerStyleChangeHandler.js';
export interface WebComponentClass {
    new (): HTMLElement & {
        cssPropertyChangedHandler?: never;
        connectedCallback?(): void;
        disconnectedCallback?(): void;
        adoptedCallback?(): void;
        attributeChangedCallback?(name: string, oldValue: null | string, newValue: null | string): void;
    };
    observedCSSProperties?: never;
    observedAttributes?: string[];
    /**
     * for attribute="false",
     * we will do removeAttribute by default;
     * set here for dont do this;
     */
    notToFilterFalseAttributes?: Set<string>;
    registerPlugin?: (reactiveClass: AttributeReactiveClass<WebComponentClass>) => void;
}
export type UseCSSCustomPropertyHandler = (newValue: string, propertyName: string) => void;
export interface AttributeReactiveClass<T extends typeof HTMLElement> {
    observedAttributes: readonly string[];
    observedCSSProperties?: readonly string[];
    new (dom: InstanceType<T>): any;
}
export type AttributeReactiveObject = {
    attributeChangedHandler?: Record<string, {
        handler: AttributeChangeHandler;
        noDomMeasure: boolean;
    }>;
    cssPropertyChangedHandler?: Record<string, StyleChangeHandler>;
    dispose?(): void;
    connectedCallback?(): void;
};
export declare function Component<T extends WebComponentClass>(tag: string, attributeReactiveClasses: AttributeReactiveClass<T>[], template?: string): (target: T, context: ClassDecoratorContext<T>) => T;
