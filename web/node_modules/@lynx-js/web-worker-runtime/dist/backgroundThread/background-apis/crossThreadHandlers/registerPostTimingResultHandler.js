// Copyright 2023 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
import { postTimingResult, } from '@lynx-js/web-constants';
const ListenerKeys = {
    onSetup: 'lynx.performance.timing.onSetup',
    onUpdate: 'lynx.performance.timing.onUpdate',
};
export function registerPostTimingResultHandler(uiThreadRpc, tt, pipelineIdToTimingFlags) {
    let setupTimingSaved = {};
    uiThreadRpc.registerHandler(postTimingResult, (pipelineId, updateTimingStamps, timingFlags, setupTimingStamps) => {
        if (setupTimingStamps) {
            setupTimingSaved = setupTimingStamps;
            const timingInfo = {
                extra_timing: {},
                setup_timing: setupTimingStamps,
                update_timings: {},
                metrics: {},
                has_reload: false,
                thread_strategy: 0,
                url: '',
            };
            tt.GlobalEventEmitter.emit(ListenerKeys.onSetup, [timingInfo]);
        }
        else {
            const flags = [
                ...timingFlags,
                ...(pipelineIdToTimingFlags.get(pipelineId) ?? []),
            ];
            const timingInfo = {
                extra_timing: {},
                setup_timing: setupTimingSaved,
                update_timings: Object.fromEntries([...flags].map(flag => [flag, updateTimingStamps])),
                metrics: {},
                has_reload: false,
                thread_strategy: 0,
                url: '',
            };
            tt.GlobalEventEmitter.emit(ListenerKeys.onUpdate, [timingInfo]);
        }
        if (pipelineId) {
            pipelineIdToTimingFlags.delete(pipelineId);
        }
    });
}
//# sourceMappingURL=registerPostTimingResultHandler.js.map