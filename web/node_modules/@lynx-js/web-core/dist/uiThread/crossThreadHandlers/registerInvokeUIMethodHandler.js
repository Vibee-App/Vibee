import { Rpc } from '@lynx-js/web-worker-rpc';
import { queryNodes } from './queryNodes.js';
import { ErrorCode, lynxRuntimeValue, invokeUIMethodEndpoint, } from '@lynx-js/web-constants';
const methodAlias = {
    'boundingClientRect': (element) => {
        const rect = element.getBoundingClientRect();
        return {
            id: element.id,
            dataset: element[lynxRuntimeValue]
                .dataset,
            width: rect.width,
            height: rect.height,
            left: rect.left,
            right: rect.right,
            top: rect.top,
            bottom: rect.bottom,
        };
    },
};
export function registerInvokeUIMethodHandler(rpc, rootDom) {
    let code = ErrorCode.UNKNOWN;
    let data = undefined;
    rpc.registerHandler(invokeUIMethodEndpoint, (type, identifier, component_id, method, params, root_unique_id) => {
        queryNodes(rootDom, type, identifier, component_id, true, root_unique_id, (element) => {
            try {
                const aliasMethod = methodAlias[method];
                const hasDomMethod = typeof element[method] === 'function';
                if (!aliasMethod && !hasDomMethod) {
                    code = ErrorCode.METHOD_NOT_FOUND;
                }
                else {
                    if (aliasMethod) {
                        data = aliasMethod(element, params);
                    }
                    else {
                        data = element[method](params);
                    }
                    code = ErrorCode.SUCCESS;
                }
            }
            catch (e) {
                console.error(`[lynx-web] invokeUIMethod: apply method faild with`, e, element);
                code = ErrorCode.PARAM_INVALID;
            }
        }, (error) => {
            code = error;
        });
        return { code, data };
    });
}
//# sourceMappingURL=registerInvokeUIMethodHandler.js.map