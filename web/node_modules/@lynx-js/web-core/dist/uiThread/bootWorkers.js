// Copyright 2023 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
import { Rpc } from '@lynx-js/web-worker-rpc';
let preHeatedMainWorker = createMainWorker();
export function bootWorkers() {
    const curMainWorker = preHeatedMainWorker;
    const curBackgroundWorker = createBackgroundWorker(curMainWorker.channelMainThreadWithBackground);
    preHeatedMainWorker = createMainWorker();
    return {
        mainThreadRpc: curMainWorker.mainThreadRpc,
        backgroundRpc: curBackgroundWorker.backgroundRpc,
        terminateWorkers: () => {
            curMainWorker.mainThreadWorker.terminate();
            curBackgroundWorker.backgroundThreadWorker.terminate();
        },
    };
}
function createMainWorker() {
    const channelToMainThread = new MessageChannel();
    const channelMainThreadWithBackground = new MessageChannel();
    const mainThreadWorker = new Worker(new URL('@lynx-js/web-worker-runtime', import.meta.url), {
        type: 'module',
        name: `lynx-main`,
    });
    const mainThreadMessage = {
        mode: 'main',
        toUIThread: channelToMainThread.port2,
        toPeerThread: channelMainThreadWithBackground.port1,
    };
    mainThreadWorker.postMessage(mainThreadMessage, [
        channelToMainThread.port2,
        channelMainThreadWithBackground.port1,
    ]);
    const mainThreadRpc = new Rpc(channelToMainThread.port1, 'ui-to-main');
    return {
        mainThreadRpc,
        mainThreadWorker,
        channelMainThreadWithBackground,
    };
}
function createBackgroundWorker(channelMainThreadWithBackground) {
    const channelToBackground = new MessageChannel();
    const backgroundThreadWorker = new Worker(new URL('@lynx-js/web-worker-runtime', import.meta.url), {
        type: 'module',
        name: `lynx-bg`,
    });
    const backgroundThreadMessage = {
        mode: 'background',
        toUIThread: channelToBackground.port2,
        toPeerThread: channelMainThreadWithBackground.port2,
    };
    backgroundThreadWorker.postMessage(backgroundThreadMessage, [
        channelToBackground.port2,
        channelMainThreadWithBackground.port2,
    ]);
    const backgroundRpc = new Rpc(channelToBackground.port1, 'ui-to-bg');
    return { backgroundRpc, backgroundThreadWorker };
}
//# sourceMappingURL=bootWorkers.js.map