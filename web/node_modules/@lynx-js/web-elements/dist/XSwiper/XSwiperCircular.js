import { __esDecorate, __runInitializers, __setFunctionName } from "tslib";
/*
// Copyright 2024 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
*/
import { bindSwitchToEventListener, genDomGetter, registerAttributeHandler, } from '@lynx-js/web-elements-reactive';
let XSwiperCircular = (() => {
    let _instanceExtraInitializers = [];
    let _private_handleCircular_decorators;
    let _private_handleCircular_descriptor;
    let _private_handleVerticalChange_decorators;
    let _private_handleVerticalChange_descriptor;
    return class XSwiperCircular {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _private_handleCircular_decorators = [registerAttributeHandler('circular', false)];
            _private_handleVerticalChange_decorators = [registerAttributeHandler('vertical', true)];
            __esDecorate(this, _private_handleCircular_descriptor = { value: __setFunctionName(function (newVal) {
                    this.#listeners.forEach((l) => l(newVal));
                    if (newVal !== null) {
                        this.#dom.setAttribute('x-enable-change-event-for-indicator', '');
                        this.#changeEventHandler({
                            detail: {
                                current: this.#dom.current,
                                isDragged: false,
                                __isFirstLayout: true,
                            },
                        });
                    }
                }, "#handleCircular") }, _private_handleCircular_decorators, { kind: "method", name: "#handleCircular", static: false, private: true, access: { has: obj => #handleCircular in obj, get: obj => obj.#handleCircular }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, _private_handleVerticalChange_descriptor = { value: __setFunctionName(function (newVal) {
                    const enable = newVal !== null;
                    this.#isVertical = enable;
                }, "#handleVerticalChange") }, _private_handleVerticalChange_decorators, { kind: "method", name: "#handleVerticalChange", static: false, private: true, access: { has: obj => #handleVerticalChange in obj, get: obj => obj.#handleVerticalChange }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static observedAttributes = ['circular', 'vertical'];
        #dom = __runInitializers(this, _instanceExtraInitializers);
        #isVertical = false;
        #pervTouchPosition;
        #currentScrollDistance = 0;
        #getContentContainer = genDomGetter(() => this.#dom.shadowRoot, '#content').bind(this);
        constructor(dom) {
            this.#dom = dom;
        }
        #getCircularFirstSlot = genDomGetter(() => this.#dom.shadowRoot, '#circular-start').bind(this);
        #getCircularLastSlot = genDomGetter(() => this.#dom.shadowRoot, '#circular-end').bind(this);
        #changeEventHandler(eventLikeObject) {
            const numberOfChlidren = this.#dom.childElementCount;
            if (numberOfChlidren > 2) {
                const { current, isDragged, __isFirstLayout } = eventLikeObject.detail;
                if (current === 0
                    || current === numberOfChlidren - 1
                    || current === 2
                    || current === numberOfChlidren - 2) {
                    /**
                     * for current = 0
                     * start:[lastElement]
                     * main: [firstElement, ....]
                     * end: []
                     *
                     * for current = EOF
                     *
                     * start: []
                     * main: [..., lastElement],
                     * end: [firstElement]
                     */
                    const contentContainer = this.#getContentContainer();
                    const elementsAtStart = this.#getCircularFirstSlot().assignedElements();
                    const elementsAtEnd = this.#getCircularLastSlot().assignedElements();
                    const firstElement = this.#dom.firstElementChild;
                    const lastElement = this.#dom.lastElementChild;
                    const snapDistance = this.#dom.snapDistance;
                    let targetElement;
                    if (current === 0) {
                        elementsAtEnd.forEach((e) => e.removeAttribute('slot'));
                        lastElement.setAttribute('slot', 'circular-start');
                        targetElement = firstElement;
                    }
                    else if (current === numberOfChlidren - 1) {
                        elementsAtStart.forEach((e) => e.removeAttribute('slot'));
                        firstElement.setAttribute('slot', 'circular-end');
                        targetElement = lastElement;
                    }
                    else {
                        elementsAtStart.forEach((e) => e.removeAttribute('slot'));
                        elementsAtEnd.forEach((e) => e.removeAttribute('slot'));
                        targetElement = this.#dom.children[current];
                    }
                    // make sure the center offset of first element does not change.
                    // make scrollleft + midWidth/2 = offsetLeft/2 + itemWidth - snapDistance
                    if (this.#isVertical) {
                        const midHeight = this.#dom.getAttribute('mode') === 'carousel'
                            ? (contentContainer.clientHeight * 0.8) / 2
                            : contentContainer.clientHeight / 2;
                        this.#currentScrollDistance = targetElement.offsetTop
                            + targetElement.offsetHeight / 2
                            - snapDistance
                            - midHeight;
                        contentContainer.scrollTop = this.#currentScrollDistance;
                    }
                    else {
                        const midWidth = this.#dom.getAttribute('mode') === 'carousel'
                            ? (contentContainer.clientWidth * 0.8) / 2
                            : contentContainer.clientWidth / 2;
                        this.#currentScrollDistance = targetElement.offsetLeft
                            + targetElement.offsetWidth / 2
                            - snapDistance
                            - midWidth;
                        contentContainer.scrollLeft = this.#currentScrollDistance;
                    }
                    if (!isDragged) {
                        const mode = this.#dom.getAttribute('mode');
                        // first layout, the following mode position is the leftmost, no scrollToSnapPosition is needed
                        if (__isFirstLayout
                            && (mode === null || mode === 'normal' || mode === 'carousel'
                                || mode === 'carry')) {
                            return;
                        }
                        // first layout should always scroll instant
                        this.#scrollToSnapPosition(__isFirstLayout ? 'instant' : 'smooth');
                    }
                }
            }
        }
        #scrollToSnapPosition(behavior) {
            const contentContainer = this.#getContentContainer();
            const snapDistance = this.#dom.snapDistance;
            contentContainer.scrollBy({
                top: this.#isVertical ? snapDistance : 0,
                left: this.#isVertical ? 0 : snapDistance,
                behavior: behavior ?? 'smooth',
            });
        }
        #listeners = [
            bindSwitchToEventListener(() => this.#dom, 'change', this.#changeEventHandler.bind(this), { passive: true }),
            bindSwitchToEventListener(() => this.#dom, 'touchmove', this.#handleTouchEvent.bind(this), { passive: false }),
            bindSwitchToEventListener(() => this.#dom, 'touchend', this.#handleEndEvent.bind(this), { passive: false }),
            bindSwitchToEventListener(() => this.#dom, 'touchcancel', this.#handleEndEvent.bind(this), { passive: false }),
        ];
        get #handleCircular() { return _private_handleCircular_descriptor.value; }
        #handleTouchEvent(event) {
            const touch = event.touches.item(0);
            if (touch) {
                const currentTouchPosition = this.#isVertical ? touch.pageY : touch.pageX;
                if (this.#pervTouchPosition !== undefined) {
                    this.#startScrolling();
                    const scrollMoveDistance = this.#pervTouchPosition
                        - currentTouchPosition;
                    this.#currentScrollDistance += scrollMoveDistance;
                }
                this.#pervTouchPosition = currentTouchPosition;
            }
        }
        #handleEndEvent(_event) {
            this.#stopScrolling();
            this.#scrollToSnapPosition();
            this.#pervTouchPosition = undefined;
        }
        get #handleVerticalChange() { return _private_handleVerticalChange_descriptor.value; }
        #scrollTimer;
        #startScrolling() {
            if (!this.#scrollTimer) {
                const contentContainer = this.#getContentContainer();
                this.#currentScrollDistance = this.#isVertical
                    ? contentContainer.scrollTop
                    : contentContainer.scrollLeft;
                this.#scrollTimer = setInterval(() => {
                    if (this.#isVertical) {
                        contentContainer.scrollTop = this.#currentScrollDistance;
                    }
                    else {
                        contentContainer.scrollLeft = this.#currentScrollDistance;
                    }
                }, 10);
            }
        }
        #stopScrolling() {
            if (this.#scrollTimer) {
                clearInterval(this.#scrollTimer);
                this.#scrollTimer = undefined;
            }
        }
        dispose() {
            this.#stopScrolling();
        }
    };
})();
export { XSwiperCircular };
//# sourceMappingURL=XSwiperCircular.js.map