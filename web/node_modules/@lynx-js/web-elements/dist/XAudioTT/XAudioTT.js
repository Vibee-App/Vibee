import { __esDecorate, __runInitializers } from "tslib";
/*
// Copyright 2024 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
*/
import { Component, html, genDomGetter, bindToAttribute, } from '@lynx-js/web-elements-reactive';
import { XAudioAttribute } from './XAudioAttribute.js';
import { XAudioEvents } from './XAudioEvents.js';
import { LynxExposure } from '../common/Exposure.js';
import { commonComponentEventSetting } from '../common/commonEventInitConfiguration.js';
import { XAudioErrorCode, audioPlaybackStateMap, getAudioState, xAudioBlob, xAudioSrc, } from './utils.js';
let XAudioTT = (() => {
    let _classDecorators = [Component('x-audio-tt', [LynxExposure, XAudioAttribute, XAudioEvents], html `<audio id="audio"></audio>`)];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _classSuper = HTMLElement;
    var XAudioTT = class extends _classSuper {
        static { _classThis = this; }
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
            XAudioTT = _classThis = _classDescriptor.value;
            if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            __runInitializers(_classThis, _classExtraInitializers);
        }
        #getAudio = genDomGetter(() => this.shadowRoot, '#audio');
        #getAudioElement = genDomGetter(() => this.shadowRoot, '#audio');
        #setAudioSrc = bindToAttribute(this.#getAudioElement, 'src');
        [xAudioSrc];
        [xAudioBlob];
        #fetchAudio = () => {
            const parsedSrc = this[xAudioSrc];
            if (!parsedSrc || !parsedSrc.id || !parsedSrc.play_url) {
                return;
            }
            let parsedHeaders;
            try {
                parsedHeaders = JSON.parse(this.getAttribute('headers') || '{}')
                    || {};
            }
            catch (error) {
                console.error(`JSON.parse headers error: ${error}`);
                parsedHeaders = {};
            }
            this[xAudioBlob] = new Promise(async (resolve, reject) => {
                this.dispatchEvent(new CustomEvent('srcloadingstatechanged', {
                    ...commonComponentEventSetting,
                    detail: {
                        code: 0,
                        type: 'loading',
                        currentSrcID: parsedSrc.id,
                    },
                }));
                const response = await fetch(parsedSrc.play_url, {
                    headers: parsedHeaders,
                });
                if (!response.ok) {
                    this.dispatchEvent(new CustomEvent('error', {
                        ...commonComponentEventSetting,
                        detail: {
                            code: XAudioErrorCode.DownloadError,
                            msg: '',
                            from: 'res loader',
                            currentSrcID: parsedSrc.id,
                        },
                    }));
                    reject();
                }
                this.dispatchEvent(new CustomEvent('srcloadingstatechanged', {
                    ...commonComponentEventSetting,
                    detail: {
                        code: 1,
                        type: 'success',
                        currentSrcID: parsedSrc.id,
                    },
                }));
                const blob = await response.blob();
                const blobUrl = URL.createObjectURL(blob);
                this.#setAudioSrc(blobUrl);
                resolve();
            });
        };
        play() {
            // If prepare method is not called, needs to fetch first
            if (!this[xAudioBlob]) {
                this.#fetchAudio();
            }
            this[xAudioBlob]?.then(() => {
                const audio = this.#getAudio();
                audio.currentTime = 0;
                audio.play();
            });
            return {
                currentSrcID: this[xAudioSrc]?.id,
                loadingSrcID: '',
            };
        }
        stop() {
            const audio = this.#getAudio();
            const playbackState = audioPlaybackStateMap['stop'];
            this.dispatchEvent(new CustomEvent('playbackstatechanged', {
                ...commonComponentEventSetting,
                detail: {
                    code: playbackState?.code,
                    type: playbackState?.type,
                    currentSrcID: this[xAudioSrc]?.id,
                },
            }));
            audio.currentTime = 0;
            audio.pause();
            return {
                currentSrcID: this[xAudioSrc]?.id,
            };
        }
        pause() {
            const audio = this.#getAudio();
            audio.pause();
            return {
                currentSrcID: this[xAudioSrc]?.id,
            };
        }
        resume() {
            const audio = this.#getAudio();
            audio.play();
            return {
                currentSrcID: this[xAudioSrc]?.id,
                loadingSrcID: '',
            };
        }
        seek(params) {
            const audio = this.#getAudio();
            audio.currentTime = (params.currentTime || 0) / 1000;
            this.dispatchEvent(new CustomEvent('seek', {
                ...commonComponentEventSetting,
                detail: {
                    seekresult: 1,
                    currentSrcID: this[xAudioSrc]?.id,
                },
            }));
            return {
                currentSrcID: this[xAudioSrc]?.id,
            };
        }
        mute(params) {
            const audio = this.#getAudio();
            audio.muted = params.mute;
            return {
                currentSrcID: this[xAudioSrc]?.id,
            };
        }
        playerInfo() {
            const audioElement = this.#getAudio();
            const buffered = audioElement.buffered;
            const cacheTime = buffered.end(buffered.length - 1);
            return {
                currentSrcID: this[xAudioSrc]?.id,
                duration: audioElement.duration * 1000,
                playbackState: getAudioState(audioElement),
                // playBitrate can not support now
                currentTime: audioElement.currentTime,
                cacheTime,
            };
        }
        prepare() {
            // if has fetched, no need to fetch again
            if (!this[xAudioBlob]) {
                this.#fetchAudio();
            }
        }
        setVolume(params) {
            const audio = this.#getAudio();
            audio.volume = params.volume;
            return {
                code: 1,
            };
        }
    };
    return XAudioTT = _classThis;
})();
export { XAudioTT };
//# sourceMappingURL=XAudioTT.js.map