import { __esDecorate, __runInitializers } from "tslib";
/*
// Copyright 2024 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
*/
import { Component, genDomGetter, html } from '@lynx-js/web-elements-reactive';
import { InputBaseAttributes } from './InputBaseAttributes.js';
import { Placeholder } from './Placeholder.js';
import { XInputAttribute } from './XInputAttribute.js';
import { XInputEvents } from './XInputEvents.js';
import { LynxExposure } from '../common/Exposure.js';
let XInput = (() => {
    let _classDecorators = [Component('x-input', [
            LynxExposure,
            Placeholder,
            XInputAttribute,
            InputBaseAttributes,
            XInputEvents,
        ], html ` <style>
      #input:focus {
        outline: none;
      }
      #form {
        display: none;
      }
    </style>
    <form id="form" part="form" method="dialog">
      <input
        id="input"
        part="input"
        step="any"
        type="text"
        inputmode="text"
        spell-check="true"
      />
    </form>`)];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _classSuper = HTMLElement;
    var XInput = class extends _classSuper {
        static { _classThis = this; }
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
            XInput = _classThis = _classDescriptor.value;
            if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            __runInitializers(_classThis, _classExtraInitializers);
        }
        #getInput = genDomGetter(() => this.shadowRoot, '#input');
        addText(params) {
            const { text } = params;
            const input = this.#getInput();
            const selectionStart = input.selectionStart;
            if (selectionStart === null) {
                input.value = text;
            }
            else {
                const currentValue = input.value;
                input.value = currentValue.slice(0, selectionStart)
                    + text
                    + currentValue.slice(selectionStart);
            }
        }
        controlKeyBoard(params) {
            const { action } = params;
            if (action === 0 || action === 1) {
                this.focus();
            }
            else if (action === 2 || action === 3) {
                this.blur();
            }
        }
        setValue(params) {
            const input = this.#getInput();
            input.value = params.value;
            let cursorIndex;
            if ((cursorIndex = params.index)) {
                input.setSelectionRange(cursorIndex, cursorIndex);
            }
        }
        sendDelEvent(params) {
            let { action, length } = params;
            const input = this.#getInput();
            if (action === 1) {
                length = 1;
            }
            const selectionStart = input.selectionStart;
            if (selectionStart === null) {
                const currentValue = input.value;
                input.value = input.value.substring(0, currentValue.length - length);
            }
            else {
                const currentValue = input.value;
                input.value = currentValue.slice(0, selectionStart - length)
                    + currentValue.slice(selectionStart);
            }
        }
        setInputFilter(params) {
            this.#getInput().setAttribute('pattern', params.pattern);
        }
        select() {
            const input = this.#getInput();
            input.setSelectionRange(0, input.value.length);
        }
        setSelectionRange(params) {
            this.#getInput().setSelectionRange(params.selectionStart, params.selectionEnd);
        }
        focus(options) {
            this.#getInput().focus(options);
        }
        blur() {
            this.#getInput().blur();
        }
        connectedCallback() {
            const input = this.#getInput();
            if (this.getAttribute('confirm-type') === null) {
                input.setAttribute('confirm-type', 'send');
            }
            if (this.getAttribute('maxlength') === null) {
                input.setAttribute('maxlength', '140');
            }
        }
    };
    return XInput = _classThis;
})();
export { XInput };
//# sourceMappingURL=XInput.js.map