import { __esDecorate, __runInitializers, __setFunctionName } from "tslib";
/*
// Copyright 2024 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
*/
import { genDomGetter, registerAttributeHandler, } from '@lynx-js/web-elements-reactive';
import { commonComponentEventSetting } from '../common/commonEventInitConfiguration.js';
import { useScrollEnd } from '../common/constants.js';
let XViewpagerNgEvents = (() => {
    let _instanceExtraInitializers = [];
    let _private_enableScrollEventListener_decorators;
    let _private_enableScrollEventListener_descriptor;
    return class XViewpagerNgEvents {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _private_enableScrollEventListener_decorators = [registerAttributeHandler('x-enable-change-event', true), registerAttributeHandler('x-enable-offsetchange-event', true)];
            __esDecorate(this, _private_enableScrollEventListener_descriptor = { value: __setFunctionName(function () {
                    this.#enableChange =
                        this.#dom.getAttribute('x-enable-change-event') !== null;
                    const enableOffsetChange = this.#dom.getAttribute('x-enable-offsetchange-event') !== null;
                    const scrollContainer = this.#getScrollContainer();
                    if (enableOffsetChange !== null || this.#enableChange) {
                        scrollContainer.addEventListener('scroll', this.#scrollHandler, {
                            passive: true,
                        });
                    }
                    else {
                        scrollContainer.removeEventListener('scroll', this.#scrollHandler);
                    }
                    if (useScrollEnd && this.#enableChange) {
                        scrollContainer.addEventListener('scrollend', this.#scrollEndHandler, {
                            passive: true,
                        });
                    }
                    else {
                        scrollContainer.removeEventListener('scrollend', this.#scrollEndHandler);
                    }
                }, "#enableScrollEventListener") }, _private_enableScrollEventListener_decorators, { kind: "method", name: "#enableScrollEventListener", static: false, private: true, access: { has: obj => #enableScrollEventListener in obj, get: obj => obj.#enableScrollEventListener }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static observedAttributes = [
            'x-enable-change-event',
            'x-enable-offsetchange-event',
        ];
        #dom = __runInitializers(this, _instanceExtraInitializers);
        #isDragging = false;
        #connected = false;
        #currentIndex = 0;
        #enableChange = false;
        #debounceScrollForMockingScrollEnd;
        constructor(dom) {
            this.#dom = dom;
        }
        #getScrollContainer = genDomGetter(() => this.#dom.shadowRoot, '#content');
        #scrollHandler = () => {
            if (!this.#connected)
                return;
            const scrollContainer = this.#getScrollContainer();
            const oneItemWidth = this.#dom.clientWidth;
            const scrollLeft = scrollContainer.scrollLeft;
            const innerOffset = scrollLeft / oneItemWidth;
            if (this.#enableChange && !useScrollEnd) {
                // debounce
                clearTimeout(this.#debounceScrollForMockingScrollEnd);
                this.#debounceScrollForMockingScrollEnd = setTimeout(() => {
                    this.#scrollEndHandler();
                }, 100);
            }
            this.#dom.dispatchEvent(new CustomEvent('offsetchange', {
                ...commonComponentEventSetting,
                detail: { offset: innerOffset },
            }));
        };
        #scrollEndHandler = () => {
            if (this.#connected) {
                const scrollContainer = this.#getScrollContainer();
                const oneItemWidth = this.#dom.clientWidth;
                const scrollLeft = scrollContainer.scrollLeft;
                const currentIndex = Math.floor(scrollLeft / oneItemWidth);
                if (currentIndex !== this.#currentIndex) {
                    this.#dom.dispatchEvent(new CustomEvent('change', {
                        ...commonComponentEventSetting,
                        detail: { index: currentIndex, isDragged: this.#isDragging },
                    }));
                    this.#currentIndex = currentIndex;
                }
            }
        };
        #touchStartHandler = () => {
            this.#isDragging = true;
        };
        #touchEndHandler = () => {
            this.#isDragging = false;
        };
        get #enableScrollEventListener() { return _private_enableScrollEventListener_descriptor.value; }
        connectedCallback() {
            this.#connected = true;
            const scrollContainer = this.#getScrollContainer();
            this.#dom.addEventListener('touchstart', this.#touchStartHandler, {
                passive: true,
            });
            scrollContainer.addEventListener('touchend', this.#touchEndHandler, {
                passive: true,
            });
            scrollContainer.addEventListener('touchcancel', this.#touchEndHandler, {
                passive: true,
            });
        }
        dispose() {
            const scrollContainer = this.#getScrollContainer();
            scrollContainer.removeEventListener('scroll', this.#scrollHandler);
            scrollContainer.removeEventListener('scrollend', this.#scrollEndHandler);
        }
    };
})();
export { XViewpagerNgEvents };
//# sourceMappingURL=XViewpagerNgEvents.js.map