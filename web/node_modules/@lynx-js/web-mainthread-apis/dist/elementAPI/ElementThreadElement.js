// Copyright 2023 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
import { componentIdAttribute, cssIdAttribute, OperationType, } from '@lynx-js/web-constants';
function getParentIdx(element, parent) {
    parent = parent ?? element.parent;
    const idx = parent.children.findIndex((e) => e === element);
    if (idx === -1) {
        console.error(`[lynx-web]`, element, ` is not a child of`, parent);
        throw new Error(`[lynx-web] ${element} is not a child of ${parent}`);
    }
    return idx;
}
export var RefCountType;
(function (RefCountType) {
    RefCountType[RefCountType["Element"] = 0] = "Element";
})(RefCountType || (RefCountType = {}));
export class ElementThreadElement {
    tag;
    uniqueId;
    pageConfig;
    operationsRef;
    styleInfo;
    static uniqueIdToElement = [];
    static receiveEvent(event) {
        const currentTargetUniqueId = event.currentTarget.uniqueId;
        const target = this.uniqueIdToElement[currentTargetUniqueId]?.deref();
        if (target) {
            const handler = target.eventHandlerMap[event.type]?.handler;
            if (typeof handler === 'function') {
                queueMicrotask(() => {
                    handler(event);
                });
            }
        }
        else {
            this.uniqueIdToElement[currentTargetUniqueId] = undefined;
        }
    }
    static getElementByUniqueId(uniqueId) {
        return ElementThreadElement.uniqueIdToElement[uniqueId]?.deref();
    }
    type = RefCountType.Element;
    eventHandlerMap = {};
    attributes;
    property = {
        componentConfig: {},
        dataset: {},
    };
    children = [];
    parent;
    // public parentComponentUniqueId!: number;
    constructor(tag, uniqueId, pageConfig, operationsRef, styleInfo) {
        this.tag = tag;
        this.uniqueId = uniqueId;
        this.pageConfig = pageConfig;
        this.operationsRef = operationsRef;
        this.styleInfo = styleInfo;
        this.attributes = {
            style: null,
            class: '',
            [cssIdAttribute]: null,
        };
        ElementThreadElement.uniqueIdToElement[this.uniqueId] = new WeakRef(this);
        operationsRef.operations.push({
            type: OperationType.Create,
            uid: uniqueId,
            tag: tag,
        });
    }
    setProperty(key, value) {
        this.property[key] = value;
        if (key === 'dataset') {
            this.operationsRef.operations.push({
                uid: this.uniqueId,
                type: OperationType.SetProperty,
                key: key,
                value: value,
            });
        }
    }
    setDatasetProperty(key, value) {
        this.property.dataset[key] = value;
        this.operationsRef.operations.push({
            uid: this.uniqueId,
            type: OperationType.SetDatasetProperty,
            key,
            value,
        });
    }
    setAttribute(key, value) {
        this.attributes[key] = value;
        this.operationsRef.operations.push({
            uid: this.uniqueId,
            type: OperationType.SetAttribute,
            key,
            value,
        });
    }
    getAttribute(key) {
        return this.attributes[key];
    }
    appendChild(children) {
        this.children.push(...children);
        for (const kid of children) {
            if (kid.parent) {
                // note that Node.appendChild() will do `move node` Implicitly.
                const idx = getParentIdx(kid);
                kid.parent.children.splice(idx, 1);
            }
            kid.parent = this;
        }
        this.operationsRef.operations.push({
            uid: this.uniqueId,
            type: OperationType.Append,
            cid: children.map(e => e.uniqueId),
        });
    }
    removeChild(child) {
        const idx = getParentIdx(child, this);
        this.children.splice(idx, 1);
        child.parent = undefined;
        this.operationsRef.operations.push({
            type: OperationType.Remove,
            uid: this.uniqueId,
            cid: [child.uniqueId],
        });
        return child;
    }
    replaceWithElements(newElements) {
        for (const kid of newElements) {
            if (this.parent === kid) {
                console.error(`[lynx-web] cannot replace the element`, this, `by its parent`, kid);
                throw new Error(`[lynx-web] cannot replace `);
            }
        }
        const parent = this.parent;
        if (parent) {
            const currentPosition = getParentIdx(this);
            parent.children.splice(currentPosition, 1);
            this.parent = undefined;
            for (const kid of newElements) {
                if (kid.parent) {
                    const idx = getParentIdx(kid);
                    kid.parent.children.splice(idx, 1);
                }
                kid.parent = parent;
            }
            parent.children.splice(currentPosition, 0, ...newElements);
            this.operationsRef.operations.push({
                type: OperationType.Replace,
                uid: this.uniqueId,
                nid: newElements.map(e => e.uniqueId),
            });
        }
    }
    swapWith(elementB) {
        const parentA = this.parent;
        const parentB = elementB.parent;
        const idxA = getParentIdx(this);
        const idxB = getParentIdx(elementB);
        parentA.children[idxA] = elementB;
        elementB.parent = parentA;
        parentB.children[idxB] = this;
        this.parent = parentB;
        this.operationsRef.operations.push({
            type: OperationType.SwapElement,
            uid: this.uniqueId,
            tid: elementB.uniqueId,
        });
    }
    insertBefore(child, ref) {
        if (ref) {
            const idx = getParentIdx(ref, this);
            this.children.splice(idx, 0, child);
            child.parent = this;
            this.operationsRef.operations.push({
                type: OperationType.InsertBefore,
                uid: this.uniqueId,
                cid: child.uniqueId,
                ref: ref.uniqueId,
            });
        }
        else {
            this.children.push(child);
            child.parent = this;
            this.operationsRef.operations.push({
                type: OperationType.Append,
                uid: this.uniqueId,
                cid: [child.uniqueId],
            });
        }
        return child;
    }
    updateCssInJsGeneratedStyle(classStyleStr) {
        this.operationsRef.operations.push({
            type: OperationType.UpdateCssInJs,
            uid: this.uniqueId,
            classStyleStr,
        });
    }
    setStyleProperty(key, value, important) {
        this.attributes.style = (this.attributes.style ?? '')
            + `${key}:${value ?? ''}${important ? '!important' : ''};`;
        this.operationsRef.operations.push({
            type: OperationType.SetStyleProperty,
            uid: this.uniqueId,
            key,
            value,
            im: important,
        });
    }
    setEventHandler(ename, handler, eventType) {
        let hname;
        if (handler) {
            this.eventHandlerMap[ename] = { type: eventType, handler };
            if (typeof handler === 'function') {
                hname = null;
            }
            else {
                hname = handler;
            }
        }
        else {
            this.eventHandlerMap[ename] = undefined;
        }
        this.operationsRef.operations.push({
            type: OperationType.RegisterEventHandler,
            uid: this.uniqueId,
            eventType,
            hname,
            ename,
        });
    }
    get firstElementChild() {
        return this.children[0];
    }
    get lastElementChild() {
        const childLength = this.children.length;
        return childLength > 0 ? this.children[childLength - 1] : undefined;
    }
    get nextElementSibling() {
        if (this.parent) {
            const idx = getParentIdx(this);
            return this.parent.children[idx + 1];
        }
        return;
    }
}
export class ListElement extends ElementThreadElement {
    componentAtIndex;
    enqueueComponent;
    setAttribute(key, value) {
        if (key === 'update-list-info' && value) {
            const listInfo = value;
            const { insertAction, removeAction } = listInfo;
            queueMicrotask(() => {
                for (const action of insertAction) {
                    this.componentAtIndex(this, this.uniqueId, action.position, 0, false);
                }
                for (const action of removeAction) {
                    this.enqueueComponent(this, this.uniqueId, action.position);
                }
            });
            value = value.toString();
        }
        super.setAttribute(key, value);
    }
}
//# sourceMappingURL=ElementThreadElement.js.map