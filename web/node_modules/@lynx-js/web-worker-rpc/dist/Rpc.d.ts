import type { RpcEndpoint, RpcEndpointAsync, RpcEndpointAsyncVoid, RpcEndpointBase, RpcEndpointSync, RpcEndpointSyncVoid } from './RpcEndpoint.js';
type RetEndpoint<Return> = RpcEndpointBase<[
    Return,
    boolean
], void, false, false>;
/**
 * The instance for handling MessagePort Remote Process Call
 */
export declare class Rpc {
    #private;
    private port;
    private name;
    private incId;
    /**
     * @param port one size of a message channel
     * @param name instance name
     */
    constructor(port: MessagePort, name: string);
    get nextRetId(): string;
    /**
     * @private do not use this
     * @param retId
     * @returns
     */
    private static createRetEndpoint;
    /**
     * initialize a endpoint into a function
     * @param endpoint
     */
    createCall<E extends RpcEndpointSync<unknown[], unknown>>(endpoint: E): (...args: E['_TypeParameters']) => E['_TypeReturn'];
    createCall<E extends RpcEndpointSyncVoid<unknown[]>>(endpoint: E): (...args: E['_TypeParameters']) => void;
    createCall<E extends RpcEndpointAsync<unknown[], unknown>>(endpoint: E): (...args: E['_TypeParameters']) => Promise<E['_TypeReturn']>;
    createCall<E extends RpcEndpointAsyncVoid<unknown[]>>(endpoint: E): (...args: E['_TypeParameters']) => void;
    /**
     * register a handler for an endpoint
     * @param endpoint
     * @param handler
     */
    registerHandler<T extends RetEndpoint<any>>(endpoint: T, handler: (...args: T['_TypeParameters']) => void): void;
    registerHandler<T extends RpcEndpoint<any[], any>>(endpoint: T, handler: ((...args: T['_TypeParameters']) => T['_TypeReturn']) | ((...args: T['_TypeParameters']) => Promise<T['_TypeReturn']>)): void;
    /**
     * register a property of an object as a handler
     * @param endpoint
     * @param handler
     */
    registerHandlerRef<T extends RetEndpoint<any>, const PropertyName extends string, Handler extends (...args: T['_TypeParameters']) => T['_TypeReturn']>(endpoint: T, target: {
        [key in PropertyName]: Handler | undefined;
    }, propertyName: PropertyName): void;
    registerHandlerRef<T extends RpcEndpoint<any[], any>, const PropertyName extends string, Handler extends (...args: T['_TypeParameters']) => T['_TypeReturn']>(endpoint: T, target: {
        [key in PropertyName]: Handler | undefined;
    }, propertyName: PropertyName): void;
    /**
     * register a handler "lazy" for an endpoint
     * It will add a setter for the target property name
     * once the value is set, we will add it as a handler.
     * @param endpoint
     * @param handler
     */
    /**
     * register a handler for an endpoint
     * @param endpoint
     * @param handler
     */
    registerHandlerLazy<T extends RetEndpoint<any>, const PropertyName extends string, Handler extends (...args: T['_TypeParameters']) => T['_TypeReturn']>(endpoint: T, target: {
        [key in PropertyName]: Handler | undefined;
    }, propertyName: PropertyName): void;
    registerHandlerLazy<T extends RpcEndpoint<any[], any>, const PropertyName extends string, Handler extends (...args: T['_TypeParameters']) => T['_TypeReturn']>(endpoint: T, target: {
        [key in PropertyName]: Handler | undefined;
    }, propertyName: PropertyName): void;
    /**
     * Remove the handler for the name
     * @param name
     */
    removeHandler(rpc: RpcEndpoint<unknown[], unknown>): void;
    /**
     * the low level api for sending a rpc message
     * recommend to use the `createCall`
     * @param endpoint
     * @param parameters
     */
    invoke<T extends RetEndpoint<unknown>>(endpoint: T, parameters: T['_TypeParameters']): void;
    invoke<E extends (RpcEndpointSyncVoid<unknown[]> | RpcEndpointSync<unknown[], unknown>)>(endpoint: E, parameters: E['_TypeParameters'], transfer?: Transferable[]): E['_TypeReturn'];
    invoke<E extends RpcEndpointAsyncVoid<unknown[]>>(endpoint: E, parameters: E['_TypeParameters'], transfer?: Transferable[]): void;
    invoke<E extends RpcEndpointAsync<unknown[], unknown>>(endpoint: E, parameters: E['_TypeParameters'], transfer?: Transferable[]): Promise<E['_TypeReturn']>;
    invoke<E extends RpcEndpoint<unknown[], unknown>>(endpoint: E, parameters: E['_TypeParameters'], transfer?: Transferable[]): Promise<E['_TypeReturn']> | E['_TypeReturn'];
    /**
     * create a call with callbackify parameters
     */
    createCallbackify<E extends RpcEndpointAsync<unknown[], unknown>>(endpoint: E, callbackAt: number): (...params: [...E['_TypeParameters'], (param: E['_TypeReturn']) => void]) => void;
}
export {};
