/**
 * The instance for handling MessagePort Remote Process Call
 */
export class Rpc {
    port;
    name;
    incId = 0;
    #messageCache = {};
    #textEncoder = new TextEncoder();
    #textDecoder = new TextDecoder();
    #handlerMap = new Map();
    /**
     * @param port one size of a message channel
     * @param name instance name
     */
    constructor(port, name) {
        this.port = port;
        this.name = name;
        port.onmessage = (ev) => this.#onMessage(ev.data);
    }
    get nextRetId() {
        return `ret_${this.name}_${this.incId++}`;
    }
    /**
     * @private do not use this
     * @param retId
     * @returns
     */
    static createRetEndpoint(retId) {
        return {
            name: retId,
            hasReturn: false,
            isSync: false,
        };
    }
    #onMessage = async (message) => {
        console.warn(`[rpc] on ${this.name} received ${message.name}`, message);
        const handler = this.#handlerMap.get(message.name);
        if (handler) {
            const lockViewer = message.sync
                ? new Int32Array(message.lock)
                : undefined;
            const replyTempEndpoint = (!message.sync && message.retId)
                ? Rpc.createRetEndpoint(message.retId)
                : undefined;
            try {
                const retData = await handler(...message.data);
                if (message.sync) {
                    if (message.buf) {
                        const retStr = JSON.stringify(retData);
                        const lengthViewer = new Uint32Array(message.buf, 0, 1);
                        const bufViewer = new Uint8Array(message.buf, 4);
                        const retCache = new Uint8Array(message.buf.byteLength - 4);
                        const { written: byteLength } = this.#textEncoder.encodeInto(retStr, retCache);
                        lengthViewer[0] = byteLength;
                        bufViewer.set(retCache, 0);
                    }
                    Atomics.store(lockViewer, 0, 1);
                    Atomics.notify(lockViewer, 0);
                }
                else {
                    if (message.retId) {
                        this.invoke(replyTempEndpoint, [
                            retData,
                            false,
                        ]);
                    }
                }
            }
            catch (e) {
                console.error(e);
                if (message.sync) {
                    Atomics.store(lockViewer, 0, 2);
                    Atomics.notify(lockViewer, 0);
                    lockViewer[1] = 2;
                }
                else {
                    this.invoke(replyTempEndpoint, [undefined, true]);
                }
            }
        }
        else {
            const cache = this.#messageCache[message.name];
            if (cache) {
                cache.push(message);
            }
            else {
                this.#messageCache[message.name] = [message];
            }
        }
    };
    createCall(endpoint) {
        return (...args) => {
            return this.invoke(endpoint, args);
        };
    }
    registerHandler(endpoint, handler) {
        this.#handlerMap.set(endpoint.name, handler);
        const currentCache = this.#messageCache[endpoint.name];
        if (currentCache?.length) {
            this.#messageCache[endpoint.name] = undefined;
            for (const message of currentCache) {
                this.#onMessage(message);
            }
        }
    }
    registerHandlerRef(endpoint, target, propertyName) {
        this.registerHandler(endpoint, (...args) => {
            return target[propertyName]?.call(target, ...args);
        });
    }
    registerHandlerLazy(endpoint, target, propertyName) {
        if (target[propertyName]) {
            this.registerHandlerRef(endpoint, target, propertyName);
        }
        else {
            let property = undefined;
            const rpc = this;
            Object.defineProperty(target, propertyName, {
                get() {
                    return property;
                },
                set(v) {
                    property = v;
                    if (v) {
                        rpc.registerHandlerRef(endpoint, target, propertyName);
                    }
                },
            });
        }
    }
    /**
     * Remove the handler for the name
     * @param name
     */
    removeHandler(rpc) {
        this.#handlerMap.delete(rpc.name);
    }
    invoke(endpoint, parameters, transfer = []) {
        if (endpoint.isSync) {
            const sharedBuffer = endpoint.bufferSize
                ? new SharedArrayBuffer(endpoint.bufferSize + 4)
                : undefined;
            const lock = new SharedArrayBuffer(4);
            const lockViewer = new Int32Array(lock);
            lockViewer[0] = 0;
            const message = {
                name: endpoint.name,
                data: parameters,
                sync: true,
                lock: lock,
                buf: sharedBuffer,
            };
            this.port.postMessage(message, { transfer });
            Atomics.wait(lockViewer, 0, 0);
            if (lockViewer[0] === 2) {
                // error
                throw null;
            }
            if (sharedBuffer) {
                const byteLength = (new Uint32Array(sharedBuffer, 0, 4))[0];
                const sharedBufferView = new Uint8Array(sharedBuffer, 4, byteLength);
                const localBuf = new Uint8Array(byteLength);
                localBuf.set(sharedBufferView, 0);
                const ret = localBuf
                    ? JSON.parse(this.#textDecoder.decode(localBuf))
                    : undefined;
                return ret;
            }
            else {
                return;
            }
        }
        else {
            if (endpoint.hasReturn) {
                const { promise, resolve, reject } = Promise.withResolvers();
                const retHandler = Rpc.createRetEndpoint(this.nextRetId);
                this.registerHandler(retHandler, (returnValue, error) => {
                    if (error)
                        reject();
                    resolve(returnValue);
                });
                const message = {
                    name: endpoint.name,
                    data: parameters,
                    sync: false,
                    retId: retHandler?.name,
                };
                this.port.postMessage(message, { transfer });
                return promise;
            }
            else {
                const message = {
                    name: endpoint.name,
                    data: parameters,
                    sync: false,
                };
                this.port.postMessage(message, { transfer });
            }
        }
    }
    /**
     * create a call with callbackify parameters
     */
    createCallbackify(endpoint, callbackAt) {
        const call = this.createCall(endpoint);
        return (...params) => {
            const callback = params.at(callbackAt);
            params.splice(callbackAt, 1);
            call(...params).then(callback);
        };
    }
}
//# sourceMappingURL=Rpc.js.map